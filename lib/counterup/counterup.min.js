/*!
 * jquery.counterup.js 2.1.0
 *
 * Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
 * Released under the GPL v2 License
 *
 * Amended by Jeremy Paris, Ciro Mattia Gonano and others
 *
 * Date: Feb 24, 2017
 */

(function($) {
    "use strict";

    // Adding a jQuery plugin method called 'counterUp'
    $.fn.counterUp = function(options) {
        // Default settings for counter animation
        var settings = $.extend({
            time: 400,         // Duration of the animation (in ms)
            delay: 10,         // Delay between steps (in ms)
            offset: 100,       // Offset percentage for triggering the animation
            beginAt: 0,        // Starting point for the animation
            formatter: false,  // Formatter function for custom number formatting
            context: "window", // The context in which to check for visibility (default is window)
            callback: function() {} // Callback function to call after the animation completes
        }, options);

        // Loop through each element to apply the counter animation
        return this.each(function() {
            var $this = $(this); // Current DOM element
            var counter = {
                time: $this.data("counterup-time") || settings.time,
                delay: $this.data("counterup-delay") || settings.delay,
                offset: $this.data("counterup-offset") || settings.offset,
                beginAt: $this.data("counterup-beginat") || settings.beginAt,
                context: $this.data("counterup-context") || settings.context
            };

            // Function to update the number (count-up effect)
            var counterUpper = function() {
                var nums = []; // Array to hold the numbers during the animation process
                var divisions = counter.time / counter.delay; // Total number of steps in the animation
                var num = $this.attr("data-num") ? $this.attr("data-num") : $this.text(); // Number to animate (either from data-num or element text)
                var isComma = /[0-9]+,[0-9]+/.test(num); // Check if the number contains commas
                num = num.replace(/,/g, ""); // Remove commas from number

                // Check decimal places
                var decimalPlaces = (num.split(".")[1] || []).length;

                // If the starting number is greater than the target, set it to the target
                if (counter.beginAt > num) counter.beginAt = num;

                // Check if the number is in time format (HH:MM:SS)
                var isTime = /[0-9]+:[0-9]+:[0-9]+/.test(num);
                if (isTime) {
                    var times = num.split(":");
                    var m = 1;
                    s = 0;
                    // Convert time string (HH:MM:SS) to total seconds
                    while (times.length > 0) {
                        s += m * parseInt(times.pop(), 10);
                        m *= 60;
                    }
                }

                // Create the animation steps
                for (var i = divisions; i >= counter.beginAt / num * divisions; i--) {
                    var newNum = (num / divisions * i).toFixed(decimalPlaces); // Calculate the current step's value

                    // If the value is time, format it into HH:MM:SS
                    if (isTime) {
                        newNum = parseInt(s / divisions * i);
                        var hours = parseInt(newNum / 3600) % 24;
                        var minutes = parseInt(newNum / 60) % 60;
                        var seconds = parseInt(newNum % 60, 10);
                        newNum = (hours < 10 ? "0" + hours : hours) + ":" + 
                                 (minutes < 10 ? "0" + minutes : minutes) + ":" + 
                                 (seconds < 10 ? "0" + seconds : seconds);
                    }

                    // If the number has commas, format it with commas
                    if (isComma) {
                        while (/\d+(\d{3})/.test(newNum.toString())) {
                            newNum = newNum.toString().replace(/(\d+)(\d{3})/, "$1,$2");
                        }
                    }

                    // If a custom formatter is provided, use it
                    if (settings.formatter) {
                        newNum = settings.formatter.call(this, newNum);
                    }

                    // Push the formatted number to the nums array
                    nums.unshift(newNum);
                }

                // Store the nums array in the data object of the element
                $this.data("counterup-nums", nums);
                // Set the text of the element to the starting point
                $this.text(counter.beginAt);

                // Function to update the element's text with the next value in the nums array
                var f = function() {
                    if (!$this.data("counterup-nums")) {
                        // Once the numbers are done animating, call the callback
                        settings.callback.call(this);
                        return;
                    }
                    // Update the element's text with the next number
                    $this.html($this.data("counterup-nums").shift());

                    // If there are still numbers left to display, call this function again
                    if ($this.data("counterup-nums").length) {
                        setTimeout($this.data("counterup-func"), counter.delay);
                    } else {
                        // Once the animation is complete, cleanup and call the callback
                        $this.data("counterup-nums", null);
                        $this.data("counterup-func", null);
                        settings.callback.call(this);
                    }
                };

                // Store the update function in the element's data
                $this.data("counterup-func", f);
                // Start the animation with a delay
                setTimeout($this.data("counterup-func"), counter.delay);
            };

            // Waypoints is used to detect when the element is visible in the viewport
            $this.waypoint(function(direction) {
                // When the element comes into view, trigger the counter animation
                counterUpper();
                // Destroy the waypoint listener after the animation starts
                this.destroy();
            }, {
                offset: counter.offset + "%",
                context: counter.context
            });
        });
    };
})(jQuery);
